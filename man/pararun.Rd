% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pararun.R
\name{pararun}
\alias{pararun}
\title{Parallel Execution of an Expression}
\usage{
pararun(
  X,
  expr,
  ncores = NULL,
  LB = FALSE,
  export_var = ls(envir = globalenv()),
  evalQ_expr = NULL
)
}
\arguments{
\item{X}{A list or vector of input values to be processed in parallel.}

\item{expr}{An R expression to be evaluated in parallel. It should be valid R code without quotes.}

\item{ncores}{An integer specifying the number of cores to use for parallel execution.
If \code{NULL}, all available cores will be used.}

\item{LB}{A logical indicating whether to use load balancing. Default is \code{FALSE}.}

\item{export_var}{A character vector of variable names to be exported to the cluster environment.
Default is all variables in the global environment.}

\item{evalQ_expr}{An optional expression to be evaluated on each worker before executing the main expression.}
}
\value{
A list of results from the execution of the expression for each element in X.
}
\description{
This function executes a given R expression in parallel across multiple cores using the socket approach via parLapply.
}
\details{
This is a wrapper function of \code{parLapply} in the \code{parallel} package.
}
\examples{
agent_attr <- data.frame(age = rep(0, 2))
f <- function(){self$age <- self$age + 1}
agents <- init_agent(n = 2, attr_df = agent_attr, act_FUN = f)
G <- setABM(agents = agents)
pararun(X = 1:3, expr = runABM(G = G, schedule = "f"), ncores = 2)
pararun(X = 1:3,
        expr = {
          G_res <- runABM(G = G)
          G_res$agents$ID1
        }, ncores = 2)
}
